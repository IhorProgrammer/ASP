@inject ASP.Services.Hash.IHashService hashService
@{
	ViewData["Title"] = "Ioc";
}
   
<h1 class="display-4">Іноверсія управління</h1>
<p>
	Інверсія управління (Ioc, Inversion of Control) - схема побудови архітектури проєкту, за якої управління життєвим циклом об'єктів делегується в окремому модулі. 
	Життєвий цикл - CRUD - створення, впровадження, модифікація, видалення.
	Ідея полягає у тому, що спочатку відбувається реєстрація служб - провайдерів об'єктів.
	На другому єтамі відбувається розв'зування ( Resolve ) залежностей, тобто побудова об'єкту з усіма заявеннями залежностями від інших об'єктів (служб, сервісів )
</p>
<p>
	DIP (Dipendency Inversion Principle) - принцип інверсії залежностей ( не путати з IOC ) 
	- один з принципів SOLID, який пропрнує створювати залежності не від конкретних типів, а від інтерфейсів. 
	Це дозволяє легко змінити один тип на інший, якщо вони реалізують один інтерфейс.
</p>
<p>
	На прикладі служби гешування
</p>
<ul>
	<li>
		Сервіси с структурною частиною проєкту, ьільш того,часто мають універсальне значення ( можуть бути перенесені до іншого проєкту).)ю
		Відповідно для них створюється папка на найвищому рівні.
	</li>
	<li>
		За рекомендаціями DIP/SOLID навіть одиночний сервіс-клас має супроводжуватись інтерфейсом,
		тобто на один сервіс припадає декілька файлів-класів. Відповідно, кожен з сервісів також уміщують в окрему папку ("Hash").
		У ній створюємо інтерйфейс та клас
	</li>

	<li>
		Реєструєм сервіс. У Program.cs знаходими розділ 
		<code>var app = builder.Build();</code>
		та додаємо інструкцію реєстрації <br/>
		<code>
			builder.Services.AddSingleton IHashService, Md5HashService>();
		</code>
		Це можна уявити як: "Будуть запитувати IHashService - видати IHashService"
	</li>
	<li>
		Заявляємо залежності - у контролері створюємо поле типу IHashService (див. HomeController)
	</li>
	<li>
		Уявляємо переход на іншу систему гешування.
		Для цього
		<ol>
			<li> У папці /Services/Hash створюємо ще один клас, який реалізуює той самий IHasService - Sha1HashService </li>
			<li> 
				У Program.cs змінюємо інструкцію реєстрації з новим класом 
				<br />
				<code>builder.Services.AddSingleton<IHashService, Sha1HashService>();</code>
			</li>
			<li>
				Перезапускаємо проект. Служба заміняєтьс автоматично
			</li>
		</ol>
	</li>
</ul>
	
<h2>Scope - область "життя" сервісу.</h2>
<p>
	При реэстрації служби зазначається її scope - поведінка щодо повторних запитів на інжекцію. <b>У ASP є три області</b>: 
</p>
<ul>
	<li>
		<b>Siglenton</b> - незаміний об'єкт, усі точки інжекції отримують посилання.
	</li>
	<li>
		<b>Transient</b> - "одноразовий", кожна точка отримує новий об'єкт.
	</li>
	<li>
		<b>Scope</b> (.AddScoped) - постійний протягом одного запиту, наступний запит - нове створення об'єкту (як час життя контролерів)
	</li>
</ul>

<p>
	hash = @ViewData["hash"]
	<br />
	hashCode(controller) = @ViewData["objHash"]
	<br />
	hashCode(view) = @(hashService.GetHashCode())
</p>
<h2>Form</h2>
<p>
	В ASP використовується дещо не трацтиційне MVC розуміння моделей - тут це об'єкти, призначені для трансферу (передачі) даних між контролерами та представленнями.
	Представлення за замовченням мають властивість "Model", але для її використання слід зазначити її тип даних інструкцію &commat;model на початку представлення.
	Властивість "Model" є тим параметром, що передається з виклику <code>return View(model);</code>
</p>
<p>
	Моделі умовно поділяються за совїм призначенням. <br />
	ViewModel (PageModel) - набыр даних для представлення <br />
	FormModel - дані від представлення (html-form) <br />
	Entity (DTO) - об'єскти, які відображають дані у сховищі (частіше за все у БД)
</p>
